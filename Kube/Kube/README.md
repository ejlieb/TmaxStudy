# Kubernetes



#### 클러스터와 노드

- 클러스터: 여러대의 서버들을 묶어서 하나의 서비스를 제공하기 위한 집합
- 노드: 클러스터에 참여하는 각각의 서버 => 마스터 노드와 워커로 나뉜다(옛날에는 슬레이브 노드라고도 했다)



#### 인프라의 추상화

- 컨테이너 시스템에서 컨테이너 어플을 쉽게 배포 관리하도록 돕는 소프트웨어 시스템
- 기본 인프라를 추상화해 개발 및 운영 팀의 개발 배포 관리를 단순화
- 모든 노드가 하나의 거대한 컴퓨터인 것처럼 수천개의 컴퓨터 노드에서 소프트웨어 어플을 실행



#### 쿠버네티스 클러스터 아키텍처

- 하드웨어 수준에서 많은 노드로 구성되며 두가지 유형으로 나뉨
  - 마스터 노드: 전체 쿠버 시스템을 관리하고 통제하는 쿠버네티스 컨트롤 플레인을 관장
  - 워커 노드: 실제 배포하고자 하는 어플의 실행을 담당



#### 쿠버네티스에서 어플 실행

1. 이미지 레지스트리에 이미지 push
2. 앱 디스크립터(문서 json or yaml)을 통해 배포 과정을 거쳐 컨트롤 플레인(마스터)에게 제출
3. 워커 노드의 kubelet(서비스 혹은 데몬)에게 명령이 전달
4. kubelet이 containerd를 컨트롤해서 이미지 레지스트리에서 pull 받은 후 컨테이너 생성



#### 클러스터 2개를 이용하는 이유

1. GKE(구글 쿠버네티스 엔진)
   - 구글이 관리하는 관리형 클러스터
   - 클러스터 세부 설정 불가
   - 클라우드 네이티브를 어느정도 바로 사용 가능
2. 온프레미스(우분투)
   - 모든 구성 요소를 직접 세팅해아 한다
   - 모든 쿠버 클러스터 설정을 직접 조각 가능하여 다양한 기능 테스트 가능



#### Ubuntu 환경에서의 쿠버네티스 클러스터 구성

kubeadm: 클러스터를 부트스트랩(구성)하는 명령. 클러스터를 초기화하고 관리하는 기능을 갖는다.

kubelet: 클러스터의 모든 머신에서 실행되는 pod과 컨테이너 시작과 같은 작업을 수행하는 컴포넌트. 데몬으로 동작하며 컨테이너를 관리

kubectl: 클러스터와 통신하기 위한 커맨드 라인 유틸리티이다. 클라이언트 전용 프로그램



1. Container Runtime(ContainerD) 설치하기

2. 쿠버네티스를 우분투에 설치

   1. kubeadm 설치

   2. 넷필터 브릿지 설정

      - 쿠버는 넷필터 브릿지 설정을 통해 컨테이너 네트워크 통신을 주관

      - ```shell
        sudo -i
        modprobe br_netfilter
        # 리눅스 커널에서 패킷 전달을 활성화
        echo 1 > /proc/sys/net/ipv4/ip_forward
        
        # 리눅스 브릿지가 인터페이스 간에 패킷이전달될 떄 iptables 규칙을 호출할 수 있도록 하며 이렇게 하면 NAT 규칙이 브랏지를 통과할 때 패킷에적용 가능  
        echo 1 > /proc/sys/net/bridge/bridge-nf-call-iptables
        ```

      - 이러한 명령은 Linux에서 NAT(네트워크 주소 변환)를 설정하는데 사용

      - NAT는 단일 공용 ip 주소를 사용하여여러 장치를 인터넷에연결하는 방법  

   3. 마스터 노드 초기화

      1. ```sh
         sudo kubeadm init
         ```

      2. 최초의 마스터노드가 init을 실행하고

      3. 토큰이 발급되어 join(다른 워커노드 혹은 마스터노드 => 토큰에 따라 달라짐)

      4. 클러스터가 구성된다.

   4. 클러스터를 사용 초기 세팅(마스터 노드에서만 실행할 것)

      1. init 시 콘솔에 출력된 내용을 복붙

   5. POD 네트워크 배포

      1. cilium을 설치





#### POD

- 컨테이너의 공동 배포된 그룹이며 쿠버네티스의 기본 빌딩 블록을 대표
- 쿠버네티스는 컨테이너를 개별적으로 배포하지 않고 컨테이너의 포드를 항상 배포하고 운영
- 일반적으로 포드는 단일컨테이너만 포함하지만 다수의 컨테이너를 포함 할 수 있음
- 포드는 다수의 노드에 생성되지 않고 단일 노드에서만 실행
- 여러 프로세스를 실행하기 위해서는 컨테이너 당 단일 프로세스가 적합
- 다수의 프로세스를 제어하려면 다수의컨테이너를 다룰 수 있는 그룹이 필요 



##### POD의 관리

- 포드는 밀접하게 연관된 프로세스를 함께 실행하고 마치 하나의 환경에서 동작하는 것처럼 보임
- 그러나 동일한 환경을 제공하면서 다소 격리된 상태로 유지



##### 동일한 포드의 컨테이너 사이의 부분 격리

- 포드의 모든 컨테이너는 동일한 네트워크 및 UTS 네임스페이스에서 실행
- 같은 호스트 이름 및 네트워크 인터페이스를 공유(포트 충돌 가능성 있음)
- 포드의 모든 컨테이너는 동일한 IPC 네임스페이스 아래에서 실행되며 IPC 통해 통신 가능



##### YAML로 포드 디스크립터만들기

- apiVersion: 쿠버네티스api 버전
- kind: 어떤 리소스유형인지 결정 (포드 레플리카컨트롤러, 서비스 등)
- 메타데이터: 포드과 관련된 이름, 네임스페이스, 라벨, 그 밖의 정보 존재
- 스펙: 컨테이너, 볼륨 등의 정보
- 상태: 포드의 상태, 각 컨테이너의 설명 및 상태, 포드 내부의 IP 밑 그 밖의 기본 정보 등   

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: http-go
spec:
  containers:
  - name: http-go
    image: gasbugs/http-go
    ports:
    - containerPort: 8080
```

