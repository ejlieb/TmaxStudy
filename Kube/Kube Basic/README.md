# Kubernetes



#### What is Kube?

쿠버네티스는 컨테이너 기반 오픈 소스 가상화 프로젝트



####  Cloud Native

클라우드 네이티브는 클라우드의 장점을 최대한 활용하여 정보 시스템을 구축 및 실행하는 환경

쿠버네티스는 클라우드 네이티브 구성요소를 완전히 수행할 수 있는 최고의 플랫폼



#### 기존 애플리케이션과 클라우드 네이티브 애플리케이션의 차이

- 기존 어플은 모놀리식 기반 위에서 동작
- 클라우드 네이티브 어플은 소규모 서비스 단위의 마이크로서비스로 구성되며 가상 컨테이너 환경에서 동작되도록 설계되고 구현
- 기존 어플은 크고 조밀한 결합 구조를, 클라운드 네이티브 어플은 느슨하고 서비스 기반 구조를 취한다.
- 기존 어플은 물리 서버 중심, 수직확장(Scale Up) / 클라우드 네이티브 어플은 가상 컨테이너 중심, 수평 확장(Scale Out)



#### 클라우드 네이티브 구성 요소

1. 마이크로 서비스
   - 독립적인 실행 및 배포가 가능한 마이크로 서비스
2. 컨테이너
   - 경량화된 컨테이너 단위 수평적 확장
3. DevOps
   - 개발팀과 운영팀간 단일한 협업 프로세스
4. CI / CD
   - 소규모 개발팀별 자율적, 독립적 서비스 운영



#### 모놀리식 아키텍처와 MSA

- 모놀리식 아키텍처
  - 전통적인 아키텍처
  - 서비스가 하나의 해플리케이션으로 돌아가는 구조
  - 기존의 개발 방식을 사용해 개발하여 간단히 배포
  - 하나의 서비스 또는 어플리케이션이 하나의 거대한 아키텍처
  - 다양한 기능을 동작하는 서비스를 실행하여 서비스
- 모놀리식의 단점
  - 아키텍처를 스케일 아웃
    - 기존의 애플리케이션을 그대로 복제하여 로드밸런싱
    - 불피요한 서비스까지 모두 복제
  - 종속적인 라이브러리의 충돌
    - 각각의 기능들은 서로 다른 기능을 제공하여 버전의 종속성을 필요한 경우가 존재
    - 각 기능에 따른 라이브러리를 매 업데이트마다 관리하기 어렵다.
  - 조금만 수정해도 전체 빌드 및 배포 필요
    - 소스코드 전체가 하나로써 동작하기 때문에 작은 수정이 있더라도 전체를 빌드하여 다시 배포해야 함
- MSA
  - 모놀리식 아키텍처의 대안으로 반대되는 개념
  - 애플리케이션의 각각의 기능을 분리하여 개발 및 관리
- MSA 장점
  - 개발자가 특정 비즈니스 로직에 대해서만 집중하여 개발 가능해 빠르게 개발 가능
  - 개별 서비스 단위로 개발, 패키징, 빌드, 테스트, 배포로 각 서비스마다 유연한 스케쥴링 가능
  - 서비스 단위로 스케일아웃이 가능하여 불필요한 서비스는 줄이고 더 많은 자원이 필요한 서비스는 확장 가능
  - 라이브러리 종속성에 관한 고민이 필요 없다.
- MSA 단점
  - 분산 시스템 환경에서 Transaction 보장, 테스트, 배포, 관리가 복잡하다.



#### DevOps

- 소프트웨어 개발과 IT 운영을 결합한 합성어
- 기존의 분리된 개발팀과 운영팀의 협업으로 전체 라이프사이클을 함께 관리할 수 있다는 일종의 철학
- 개발팀과 운영팀이 더 빠르고 안정적으로 소프트웨어를 빌드, 릴리즈할 수 있도록 두 팀 간의 프로세스를 자동화하는 일련의 과정



장점

- 속도
- 신속한 제공
- 안정성 확보
- 협업성 강화



#### 하이퍼바이저와 가상 머신

- 가상화는 전통적으로 하드웨어에 종속된 리소스를 사용해 유용한 IT 서비스를 만드는 기술
- 물리적 머신의 기능을 여러 사용자 또는 환경에 배포해 물리적 머신을 최대한 활용



#### 하이퍼바이저란

- 소프트웨어가 물리 리소스를 필요로 하는 가상 환경으로부터 물리 리소스를 분리
- 호스트 컴퓨터 1대에서 운영체제 다수를 동시에 실행하는 논리적 플랫



1. Native - type1
   - 해당 하드웨어 / 베어메탈에 직접 설치
   - 게스트 운영체제는 두번째 수준으로 실행
   - Xen, KVM, Xen Server 등
2. Hosted - type2
   - 일반 프로그램처럼 호스트 운영체제에서 실행
   - 게스트 운영체제는 세번째 수준으로 실행
   - Virtualbox, Vmware, Parrallels 등



#### 가상화 방식

1. 전가상화
   1. 하드웨어를 모두 가상화
   2. 게스트 운영체제를 변경하지 않음
   3. 물리적인 가상화를 지원하는 CPU 가상화 기술
   4. 네이티브 방식은 이 가상화를 사용
2. 반가상화
   1. 하드웨어를 완전히 가상화하지 않음
   2. 게스트 운영체제 커널 일부 수정이 필요(오픈 소스가 아니면 사용 불가)
   3. 하이퍼바이저가 모든 제어를 담당하므로 높은 성능을 유지
   4. Qemu 가 대표적인 도구



#### 컨테이너

- 컨테이너는 가상환경을 사용해 각 마이크로 서비스를 격리하는 기술
- 컨테이너는 가상머신처럼 하드웨어를 전부 구현하지 않기 때문에 매우 빠른 실행 가능



##### 리눅스 네임 스페이스 

- 컨테이너 격리 기술
- 각 프로세스가 파일 시스템 마운트, 네트워크, 유저(uid), 호스트 네임(uts) 등에 대해 시스템에 독립 뷰를 제공

##### 리눅스 컨트롤 그룹

- 프로세스로 소비할 수 있는 리소스 양(CPU, 메모리, I/O, 네트워크 대역대 등)을 제한

##### Union Mount File System

- 동일한 디렉토리에 여러 파일시스템을 마운트하는 기술
- 먼저 마운트된 것을 살려둔 상태로 추가적으로 마운트 하는 것



#### Docker

- 컨테이너 기술을 지원하는 다양한 프로젝트 중 하나
- de facto
- 리눅스의 네임스페이스와 cgroups와 같은 커널 기능을 사용하여 가상화



#### 컨테이너 레지스트리

- 컨테이너: 이미지를 격리하여 독립된 공간에서 실행한 가상 환경
- 이미지: 필요한 프로그램과 라이브러리 소스를 설치한 뒤 만든 하나의 파일
- 레지스트리: 사용자가 사용할 수 있도록 DB를 통해 Image를 제공해주고 있음

- 대표적으로 Docker Hub 등이 있음
- 필요하다면 폐쇄망이나 내부망에서 이용하기 위해 온프레미스 환경으로 운영 가능
- 대표적으로 Harbor가 있다.



#### Docker의 한계

- 서비스가 커지면 커질수록 관리해야 하는 컨테이너의 양이 급격히 증가
- 도커를 사용하여 관리를 한다 하더라도 쉽지 않다.



#### 쿠버네티스

- 다수의 컨테이너를 자동으로 운영하기 위한 오케스트레이션 도구
- 많은 시스템을 통합, 컨테이너를 다루기 위한 API 제공



- 컨테이너: 용기
- 도커: 항만 노동자
- 쿠버네티스: 항해자

라고 생각해보자. 컨테이너를 도커로 패키징하여 관리하고, 수많은 도커 컨테이너를 쿠베를 통해 오케스트레이션한다.



