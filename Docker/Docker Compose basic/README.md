# Docker Client



#### Docker 이미지 내부 파일 구조

`docker run 이미지이름 ls`

docker : docker client언급

run : 컨테이너 생성 및 실행

이미지이름: 컨테이너를 위한 이미지

ls: 현재 디렉토리의 파일 리스트 표출 / ls 자리는 이미지가 가지고 있는 시작 명령어를 무시하고 이 자리의 명령어를 실행하게 한다.



#### Docker 컨테이너 나열하기

이미지를 이용해서 컨테이너를 생성하고 실행하는데 그 컨테이너를 나열해보자.

`docker ps`

컨테이너 실행 시 --name옵션으로 이름 설정 가능

- -a 옵션 사용지 exit 된 컨테이너도 조회 가



#### Docker 생명주기

생성 - 시작 - 실행 - 중지 -삭제

`Docker run` = `Docker create` + `Docker start`



Docker create 시 이미지에 있는 파일 스냅샷을 하드디스크에 넣어준다.

Docker start 시 시작시 실행 명령어를 컨테이너에 넣고, 컨테이너가 실행하게 된다.



Docker start의 -a (attatch 옵션)을 써야 아웃풋을 화면에 표시해준다.



#### Docker Stop과 Kill

둘 다 컨테이너를 중지시킨다.

- Stop은 Gracefully하게 중지를 시킨다.

그동안 하던 작업들을 완료하고 컨테이너를 중지시킨다.

- Kill은 Stop과 달리 어떤 것 기다리지 않고 바로 중지시킨다.



#### Docker 컨테이너 삭제

- 중지된 컨테이너 삭제

  - `docker rm <아이디/이름>`

- 모든 컨테이너 삭제

  ```shell
  docker rm `docker ps -a -q`
  ```

- 이미지 삭제

  - `docker rmi <이미지id>`

- 한번에 컨테이너 이미지 네트워크 모두 삭제

  - `docker system prune`



#### 실행 중인 컨테이너에 명령어 전달

`docker exec <컨테이너 아이디>`

-it 옵션 : it를 사용해야 명령어를 실행한 후 계속 명령어를 적을 수 있다. (interactive terminal)

#### 레디스를 이용한 컨테이너 이해

1. 레디스 서버가 먼저 작동하고 있어야함
2. 이후 레디스 클라이언트 실행 후 명령어를 레디스 서버에 전달



docker run을 통해 서버 컨테이너를 작동 시킨 후 컨테이너 바깥에서 클라이언트를 실행하려고 하면 오류 발생!

exec을 통해 서버 컨테이너 안쪽에서 클라이언트를 작동시켜줘야 한다.



#### 실행중인 컨테이너 안에 쉘이나 터미널 환경으로 접속

- 마지막 명령어를 sh / bash/ zsh / powershell 등으로 주면 된다. 이미지에 따라 되는 것도 안되는 것도 있다.
- 쉘 환경에서 빠져나오려면 ctrl + c 대신 crtl +d!



#### 도커 이미지를 직접 만들기

1. Dockerfile 작성
2. Docker 클라이언트에 전달
3. Docker Server에서 작업
4. 이미지 생성



- Docker File은 도커 이미지를 만들기 위한 설정 파일. 컨테이너가 어떻게 행동해야 하는지에 대한 설정들을 정의한다.



##### 1. Docker File 만들기

1. 베이스 이미지를 명시(파일 스냅샷)
   - 베이스 이미지란?
   - 도커 이미지는 여러개의 레이어로 되어있다.
   - 베이스 이미지는 이 이미지의 기반이 되는 부분
   - 보통 OS라고 생각하면 된다.
2. 추가적으로 필요한 파일을 다운받기 위한 몇가지 명령어 명시 (파일 스냅샷)

3. 컨테이너 시작 시 실행될 명령어를 명시(시작 시 명령어)



##### 2. DockerFile 빌드하기

`docker build` 명령어 사용

- docker build 시 -t 옵션 사용 시 도커 이미지에 이름을 줄 수 있다.

- 네이밍 규칙
- -t 나의도커아이디/저장소or프로젝트이름:버전

